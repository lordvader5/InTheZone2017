#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line1,          sensorLineFollower)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    line1,          sensorLineFollower)
#pragma config(Sensor, in2,    liftsence,      sensorPotentiometer)
#pragma config(Sensor, in3,    clawsece,       sensorPotentiometer)
#pragma config(Sensor, I2C_1,  LBmotorIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  RBmotorIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  RFmotorIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  LFmotorIME,     sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           RBmotor,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port3,           LBmotor,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           RFmotor,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port5,           LFmotor,       tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           L1motor,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           L2motor,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           Cmotor,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           L3motor,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void reset()
{
	resetMotorEncoder(RFmotor);
	resetMotorEncoder(LFmotor);
	resetMotorEncoder(LBmotor);
	resetMotorEncoder(RBmotor);
}
//++++++++

void movef(int encodercount)
{
	int slowSpeed = 63;
	int normalSpeed = 75;
	while(getMotorEncoder(LBmotor) < encodercount)
	{
		if (getMotorEncoder(LFmotor) > getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = normalSpeed;
			motor(RBmotor) = normalSpeed;
			motor(LBmotor) = slowSpeed;
			motor(LFmotor) = slowSpeed;
		}

		else if(getMotorEncoder(LFmotor) < getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = slowSpeed;
			motor(RBmotor) = slowSpeed;
			motor(LBmotor) = normalSpeed;
			motor(LFmotor) = normalSpeed;
		}
		else
		{
			motor(RFmotor) = normalSpeed;
			motor(RBmotor) = normalSpeed;
			motor(LBmotor) = normalSpeed;
			motor(LFmotor) = normalSpeed;
		}
	}

	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//++++++++
void moveB(int encodercount)
{
	int slowSpeedB = -63;
	int normalSpeedB = -75;
	while(getMotorEncoder(LBmotor) > encodercount)
	{
		/*		if (getMotorEncoder(LFmotor) > getMotorEncoder(RFmotor))
		{
		motor(RFmotor) = normalSpeedB;
		motor(RBmotor) = normalSpeedB;
		motor(LBmotor) = slowSpeedB;
		motor(LFmotor) = slowSpeedB;
		}

		else if(getMotorEncoder(LFmotor) < getMotorEncoder(RFmotor))
		{
		motor(RFmotor) = slowSpeedB;
		motor(RBmotor) = slowSpeedB;
		motor(LBmotor) = normalSpeedB;
		motor(LFmotor) = normalSpeedB;
		}*/
		//else
		//	{
		motor(RFmotor) = normalSpeedB;
		motor(RBmotor) = normalSpeedB;
		motor(LBmotor) = normalSpeedB;
		motor(LFmotor) = normalSpeedB;
		//}
	}
	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//+++++++
void spinl(int encodercount)
{
	int normalSpeedf = 75;
	int slowspeedf = 63;
	//	int slowSpeedr = -63;
	int normalSpeedr = -75;
	while(getMotorEncoder(LBmotor) < encodercount)
	{
		if (getMotorEncoder(LBmotor) > getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = normalSpeedr;
			motor(RBmotor) = normalSpeedr;
			motor(LBmotor) = slowspeedf;
			motor(LFmotor) = slowspeedf;
		}

		else if(getMotorEncoder(LBmotor) < getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = slowspeedf;
			motor(RBmotor) = slowspeedf;
			motor(LBmotor) = normalSpeedr;
			motor(LFmotor) = normalSpeedr;
		}
		else
		{
			motor(RFmotor) = normalSpeedr;
			motor(RBmotor) = normalSpeedr;
			motor(LBmotor) = normalSpeedf;
			motor(LFmotor) = normalSpeedf;
		}
	}
	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//++++++
void spinr(int encodercount)
{
	int normalSpeedf = 75;
	int slowspeedf = 63;
	int slowspeedr = -63;
	int normalSpeedr = -75;
	while(getMotorEncoder(LBmotor) < encodercount)
	{
		if (getMotorEncoder(LBmotor) > getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = normalSpeedf;
			motor(RBmotor) = normalSpeedf;
			motor(LBmotor) = slowspeedr;
			motor(LFmotor) = slowspeedr;
		}

		else if(getMotorEncoder(LBmotor) < getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = slowspeedf;
			motor(RBmotor) = slowspeedf;
			motor(LBmotor) = normalSpeedr;
			motor(LFmotor) = normalSpeedr;
		}
		else
		{
			motor(RFmotor) = normalSpeedf;
			motor(RBmotor) = normalSpeedf;
			motor(LBmotor) = normalSpeedr;
			motor(LFmotor) = normalSpeedr;
		}
	}
	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//++++++
void movesr(int encodercount)
{
	int normalSpeedf = 75;
	int slowSpeedf = 63;
	int slowSpeedr = -63;
	int normalSpeedr = -75;
	while(getMotorEncoder(LFmotor) < encodercount)
	{
		/*	if (getMotorEncoder(LFmotor) > getMotorEncoder(LBmotor))
		{
		motor(RFmotor) = slowSpeedr;
		motor(RBmotor) = normalSpeedf;
		motor(LBmotor) = normalSpeedr;
		motor(LFmotor) = slowSpeedf;
		}

		else if(getMotorEncoder(LFmotor) < getMotorEncoder(LBmotor))
		{
		motor(RFmotor) = normalSpeedr;
		motor(RBmotor) = slowSpeedf;
		motor(LBmotor) = slowSpeedr;
		motor(LFmotor) = normalSpeedf;
		}
		else
		*/	//	{
		motor(RFmotor) = normalSpeedr;
		motor(RBmotor) = normalSpeedf;
		motor(LBmotor) = normalSpeedr;
		motor(LFmotor) = normalSpeedf;
		//	}
	}

	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//++++++++
void movesl(int encodercount)
{
	int normalSpeedf = 75;
	int slowSpeedf = 63;
	int slowSpeedr = -63;
	int normalSpeedr = -75;
	while(getMotorEncoder(LFmotor) < encodercount)
	{
		if (getMotorEncoder(LFmotor) > getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = normalSpeedf;
			motor(RBmotor) = normalSpeedr;
			motor(LBmotor) = slowSpeedf;
			motor(LFmotor) = slowSpeedr;
		}

		else if(getMotorEncoder(LFmotor) < getMotorEncoder(RFmotor))
		{
			motor(RFmotor) = slowSpeedf;
			motor(RBmotor) = slowSpeedr;
			motor(LBmotor) = normalSpeedf;
			motor(LFmotor) = normalSpeedr;
		}
		else
		{
			motor(RFmotor) = normalSpeedf;
			motor(RBmotor) = normalSpeedr;
			motor(LBmotor) = normalSpeedf;
			motor(LFmotor) = normalSpeedr;
		}
	}

	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
}
//++++++
void closeclaw(int potentiometer)
{
	while(SensorValue(clawsece) < potentiometer)
	{
		motor(Cmotor) = 63;
	}
	motor(Cmotor) = 0;
}
//+++++++++
void lift()
{
	motor(Cmotor) = 63;
	wait10Msec(200);
	motor(Cmotor) = 63;
	reset();
	moveB(-200);

	while(SensorValue(liftsence) < 2400)
	{


		if(SensorValue(liftsence) < 1600)
		{
			motor(L1motor) = 127;
			motor(L2motor) = 127;
			motor(L3motor) = 127;
			motor(Cmotor) = 63;
		}
		else if(SensorValue(liftsence) > 1800)
		{
			motor(L1motor) = 127;
			motor(L2motor) = 127;
			motor(L3motor) = 127;
			motor(Cmotor) = -63;
		}
	}


	motor(L1motor) = 0;
	motor(L2motor) = 0;
	motor(L3motor) = 0;
	motor(Cmotor) = 0;

}
//+++++++
void backupline()
{
	int linetrack = 505;
	if(SensorValue(line1) < linetrack)
	{
		motor(LBmotor) = -127;
		motor(LFmotor) = -127;
		motor(RBmotor) = -127;
		motor(RFmotor) = -127;
	}
	else
	{
		motor(LBmotor) = 0;
		motor(LFmotor) = 0;
		motor(RBmotor) = 0;
		motor(RFmotor) = 0;
	}
}
void lift2()
{
	motor(Cmotor) = 63;
wait10Msec(100);

	while(SensorValue(liftsence) < 2400)
	{


		if(SensorValue(liftsence) < 1600)
		{
			motor(L1motor) = 127;
			motor(L2motor) = 127;
			motor(L3motor) = 127;
		}
		else if(SensorValue(liftsence) > 1800)
		{
			motor(L1motor) = 127;
			motor(L2motor) = 127;
			motor(L3motor) = 127;
		}
	}


	motor(L1motor) = 0;
	motor(L2motor) = 0;
	motor(L3motor) = 0;

}
//++++++++++++++++++++++++++++++++++
void moveBs(int encodercount)
{
	int slowSpeedB = -63;
	int normalSpeedB = -75;
	int normalSpeed = 75;
	while(getMotorEncoder(LBmotor) > encodercount)
	{
		/*		if (getMotorEncoder(LFmotor) > getMotorEncoder(RFmotor))
		{
		motor(RFmotor) = normalSpeedB;
		motor(RBmotor) = normalSpeedB;
		motor(LBmotor) = slowSpeedB;
		motor(LFmotor) = slowSpeedB;
		}

		else if(getMotorEncoder(LFmotor) < getMotorEncoder(RFmotor))
		{
		motor(RFmotor) = slowSpeedB;
		motor(RBmotor) = slowSpeedB;
		motor(LBmotor) = normalSpeedB;
		motor(LFmotor) = normalSpeedB;
		}*/
		//else
		//	{
		motor(RFmotor) = normalSpeedB;
		motor(RBmotor) = normalSpeedB;
		motor(LBmotor) = normalSpeedB;
		motor(LFmotor) = normalSpeedB;
		motor(Cmotor) = normalSpeed;
		//}
	}
	motor(RFmotor) = 0;
	motor(RBmotor) = 0;
	motor(LBmotor) = 0;
	motor(LFmotor) = 0;
	motor(Cmotor) = 0;
}
//+++++++++++++++++++++++++++
void backuplineS()
{
	int linetrack = 505;
	if(SensorValue(line1) < linetrack)
	{
		motor(LBmotor) = -127;
		motor(LFmotor) = -127;
		motor(RBmotor) = -127;
		motor(RFmotor) = -127;
		motor(Cmotor) = 127;
	}
	else
	{
		motor(LBmotor) = 0;
		motor(LFmotor) = 0;
		motor(RBmotor) = 0;
		motor(RFmotor) = 0;
		motor(Cmotor) = 0;
	}
}
//++++++++++++++++++++++++++++++
void fourline()
{
	int linetrack = 505;
	if(SensorValue(line1) < linetrack)
	{
		motor(LBmotor) = 127;
		motor(LFmotor) = 127;
		motor(RBmotor) = 127;
		motor(RFmotor) = 127;
	}
	else
	{
		motor(LBmotor) = 0;
		motor(LFmotor) = 0;
		motor(RBmotor) = 0;
		motor(RFmotor) = 0;
		motor(Cmotor) = 0;
		}
}
//+++++++++++++++++++++++++++++++++++++
void lift3()
{
	motor(Cmotor) = -63;
wait10Msec(100);

	while(SensorValue(liftsence) > 2400)
	{


		if(SensorValue(liftsence) > 500)
		{
			motor(L1motor) = -127;
			motor(L2motor) = -127;
			motor(L3motor) = -127;
		}
	}


	motor(L1motor) = 0;
	motor(L2motor) = 0;
	motor(L3motor) = 0;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
